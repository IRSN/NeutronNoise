# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Feynman histogram
#' 
#' @description
#' This function divide the signal into equal samples of width \code{T} up to the signal duration (\code{attr(s, "duration")}). 
#' For each of them the number of events are counted and binned into a histogram called the Feynman histogram.
#' This histogram therefore represents the occurrence probabilities of various multiplets (i.e. 1 detection, 2 detections, etc.) occuring within
#' a specified time gate width \code{T}.
#' 
#' If the upper limit of the last sample exceeds the value \code{x_duration} it is not taken into account.
#' 
#' This function uses all available cores of the computer.
#' 
#' @param x A signal. The function assumes that the signal starts at the time 0 seconds.
#' @param samples_widths Numeric vector of samples width (multiple values of \code{T}).
#' @param max_nb_samples If different from 0 then the calculation is limited to the specified number of samples. 
#' @param verbose For debbuging purpose only.
#' 
#' @return A data.frame.
#' 
#' @importFrom magrittr "%>%"
#' 
#' @examples
#' artificial_signal(1000, 5) %>% feynman_hist(samples_widths = 0.8) %>% plot()
#' 
#' @seealso \link[NeutronNoise]{plot.feynman_hist} for ploting the result.
#' @export
feynman_hist <- function(x, samples_widths, max_nb_samples = 0L, verbose = 0L) {
    .Call('_NeutronNoise_feynman_hist', PACKAGE = 'NeutronNoise', x, samples_widths, max_nb_samples, verbose)
}

#' Feynman Variance-to-Mean
#' 
#' Calculation of the Feynman curve from the ratio between the variance and 
#' the mean minus 1 of the number of detections in consecutive samples.
#' Variance is calculated using Bessel's correction.
#' 
#' @param x A signal. The function assumes that the signal starts at the time 0 seconds.
#' @param samples_widths Numeric vector of samples widths.
#' @param max_nb_samples Maximum number of samples to take into account for the calculation. 
#' Unlimited if 0.
#' @param verbose For debugging purpose.
#' 
#' @return A data.frame containing for each samples width :
#' - The number of samples used
#' - The count rate "Y1"
#' - The Feynamn Variance-to-Mean value "Y"
#' - The Feynman Variance-to-Mean standard deviation "Y_std"
#' 
#' @importFrom magrittr "%>%"
#' 
#' @examples
#' mls <- data.frame(nu = 0:4, pdf = c(0.1,0.3,0.35,0.4,0.2))
#' artificial_signal(1000, hists_rate = 5000, fission_multiplicity = mls, 
#' k = 0.9, lambda = 10) %>%
#' feynman_v2m(samples_widths = lseq(from = 0.001, to = 10, 50)) %>% plot()
#' 
#' @export
feynman_v2m <- function(x, samples_widths, max_nb_samples = 0L, verbose = 0L) {
    .Call('_NeutronNoise_feynman_v2m', PACKAGE = 'NeutronNoise', x, samples_widths, max_nb_samples, verbose)
}

#' Generate virtual fission chains length
#' 
#' This function makes it possible to obtain the lengths of virtual fission chains. 
#' The length of a fission chain is defined as the total number of neutrons contained 
#' in it (this also includes the neutrons of the source event).
#' The algorithm works as follows:
#' - a first source fission is generated and eventually produces child neutrons.
#' - Each child neutron performs or not a fission with a probability and eventually produces child neutrons.
#' - The previous step is repeated until there are no more child neutrons.
#' The number of generated child neutrons depends on the multiplicity parameter.
#' Delayed neutrons are not taken into account.
#' 
#' @param n Number of virtual fission chains simulated.
#' @param fission_multiplicity A DataFrame containing the number (nu column) and the probability (pdf column) of 
#' of generated neutron per fission.
#' @param k System multiplication (between 0 and 0.99).
#' @param seed Seed of the random generator.
#' 
#' @return A list containing:
#' - the mean nu value, 
#' - the fission probability,
#' - the chains lengths.
#' 
#' @examples
#' get_fission_chains_length(fission_multiplicity = data.frame(nu = 0:2, pdf = c(0.1,0.2,0.3)), 
#' n = 5, k = 0.7)
#' 
#' @export
get_fission_chains_length <- function(n, fission_multiplicity, k, seed = 1L) {
    .Call('_NeutronNoise_get_fission_chains_length', PACKAGE = 'NeutronNoise', n, fission_multiplicity, k, seed)
}

